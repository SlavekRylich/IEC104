@startuml classes
set namespaceSeparator none
left to right direction
scale 250 width
skinparam lineType ortho
'skinparam DefaultFontSize 30


class "ClientManager" as ClientManager.ClientManager {
  - VR : int
  - VS : int
  - ack : int
  - id : int
  - ip : str
  - name : str
  - recv_buffer : PacketBuffer
  - send_buffer : PacketBuffer
  - sessions : list[Session]
  + add_session() -> Session
  + del_session(sess: Session) -> bool
  + generate_i_frame(data: bytes, session: Session) -> IFormat
  + generate_s_frame(session: Session) -> SFormat
  + generate_startdt_act() -> UFormat
  + generate_startdt_con() -> UFormat
  + handle_apdu(session: Session, apdu: Frame) -> None
  + handle_timeout_t0(session: Session) -> None
  + incrementVR() -> None
  + incrementVS() -> None
  + update_state_machine_server(session: Session, fr: Frame) -> None
}
class "ConfigLoader" as config_loader.ConfigLoader {
  + config : Any
  + file_path : str
  + load_config() -> Any | None
}
class "ConnectionState" as State.ConnectionState <<enum>> {
  - name
  + get_state() -> str
  + set_state(state: str) -> Enum
}
class "IDataSharing" as IDataSharing.IDataSharing {
  {abstract}connect(host, port, username, password)
  {abstract}disconnect()
  {abstract}publish(topic, message)
  {abstract}save_data(topic, data, callback)
  {abstract}send_data(callback)
  {abstract}subscribe(topic, callback)
}
class "MQTTProtocol" as MQTTProtocol.MQTTProtocol {
  + connect()
  + disconnect()
  + publish(topic: str, payload: bytes, qos: int, retain)
  + save_data(topic: str, data: bytes, callback)
  {abstract}send_data(callback)
  + subscribe(topic: str, callback)
  + unsubscribe(topic: str)
}
class "PacketBuffer" as Packet_buffer.PacketBuffer {
  + add_frame(frame_id: int, frame: Frame) -> None
  + clear_frames_less_than(frame_id: int) -> None
  + get_frame(frame_id: int) -> Frame
  + get_list_from_buffer() -> list
  + has_frame(frame_id: int) -> bool
  + is_empty() -> int
  + remove_frame(frame_id: int) -> None
}
class "Parser" as Parser.Parser {
  + parser(apdu, length: int) -> IFormat | SFormat | UFormat | None
}
class "ServerIEC104" as server_async.ServerIEC104 {
  - clients : dict[str, ClientManager]
  - config_loader : ConfigLoader
  - ip : str
  - name : str
  - port : int
  + check_alive_clients() -> bool
  + close() -> None
  + handle_client(reader, writer) -> None
  + listen() -> None
  + load_params(config_loader: ConfigLoader) -> tuple
  + run() -> None
  {abstract}send() -> None
}
class "Session" as Session.Session {
  - connection_state : ConnectionState
  - id : int
  - ip : str
  - k : int
  - name : str
  - port : int
  - transmission_state : TransmissionState
  - timers : Timer
  - w : int
  + delete_self() -> None
  + get_all_instances() -> list
  + get_instance(id_num: int) -> Any | None
  + handle_messages() -> None
  + send_frame(frame: Frame) -> None
  + update_timestamp_t2() -> None
}
class "Timer" as Timer.Timer {
  - timeout : int
  + cancel() -> None
  + start() -> None
}
class "TransmissionState" as State.TransmissionState <<enum>> {
  - name: str
  + get_state() -> str
  + set_state(state: str) -> Enum
}


server_async.ServerIEC104  "1" *-down- "1" config_loader.ConfigLoader

MQTTProtocol.MQTTProtocol -up-* ClientManager.ClientManager
Packet_buffer.PacketBuffer --* ClientManager.ClientManager
Packet_buffer.PacketBuffer -up-* ClientManager.ClientManager
State.ConnectionState -up[dotted]-> Session.Session
State.TransmissionState -up[dotted]-> Session.Session
Timer.Timer -up-* Session.Session


MQTTProtocol.MQTTProtocol -left-|> IDataSharing.IDataSharing

ClientManager.ClientManager -left--* server_async.ServerIEC104
Session.Session -left-* ClientManager.ClientManager
Session.Session - Parser.Parser

@enduml
